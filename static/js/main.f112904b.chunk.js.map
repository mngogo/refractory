{"version":3,"sources":["editor.js","Refractory.tsx","App.tsx","serviceWorker.js","index.js"],"names":["normalRegexen","eolRegexen","state","insertingMarkdownList","moveCursor","node","start","range","document","createRange","sel","window","getSelection","setStart","collapse","removeAllRanges","addRange","transformText","str","regexen","formatChar","slice","trimLeft","startsWith","i","newStr","headerSize","length","test","reduce","a","b","replace","processTextNode","textNode","parent","parentElement","wholeText","type","result","elt","createElement","classList","add","innerHTML","insertBefore","removeChild","contains","hnode","fmtSpan","nodeIsOrHasAncestorOfNames","execCommand","processLastTextNode","nodeType","Node","TEXT_NODE","childNodes","nodeNames","next","includes","nodeName","parentNode","Editor","editor","addEventListener","e","isComposing","keyCode","preventDefault","activeElt","anchorNode","getActiveElement","command","MutationObserver","mutations","observer","mutation","target","addedNodes","prevNode","previousSibling","li","console","log","appendChild","observe","attributes","childList","subtree","characterData","Refractory","props","ref","useRef","editorRef","useEffect","current","mount","className","contentEditable","suppressContentEditableWarning","App","href","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f112904b.chunk.js","sourcesContent":["// BUG: If you create a list with some existing text, the cursor begins at the beginning rather than the end\n// On Chrome, not Firefox\n\n// BUG: You can delete all the .rf-editor-line divs, which then breaks our assumptions\n// about how the data is structured. Don't allow the user to completely remove everything\n\n// for normal editing, we require some kind of breaking\n// character (whitespace, comma) to disambiguate\nconst normalRegexen = [\n  [/__(.+?)__([\\s,])/g, '<strong>$1</strong>$2'],\n  // TODO how does the comma work? are there stop punctuation letters?o\n  [/_(.+?)_[\\s,]/g, '<em>$1</em>&nbsp;'],\n]\n\n// for EOL we don't require following chars to handle things at the end of the line\nconst eolRegexen = [\n  [/__(.+?)__/g, '<strong>$1</strong>'],\n  [/_(.+?)_/g, '<em>$1</em>'],\n]\n\nlet state = {\n  insertingMarkdownList: false,\n};\n\n/**\n * Move a cursor to a particular location within a node\n * Used when splicing DOM nodes\n * @param {*} node \n * @param {*} start \n */\nconst moveCursor = (node, start = 0) => {\n  const range = document.createRange();\n  const sel = window.getSelection();\n  range.setStart(node, start);\n  range.collapse(true);\n  sel.removeAllRanges();\n  sel.addRange(range);\n}\n\nconst transformText = (str, regexen) => {\n  // Certain things are only processed when they are the first non-whitespace\n  // character in the first four characters of a string\n\n  // Headers & lists\n  const formatChar = str.slice(0, 4).trimLeft();\n\n  if (formatChar.startsWith('#')) {\n    let newStr = str.trimLeft()\n    let headerSize = 0;\n    // check for consecutive #'s to determine header size, check that there is a whitespace\n    // char following the # to indicate desire to header-ify\n    let i;\n    for (i = 0; i !== newStr.length; i += 1) {\n      if (newStr[i] === '#') {\n        headerSize += 1;\n        if (headerSize === 6) break;\n      } else {\n        i -= 1;\n        break;\n      }\n    }\n\n    // We have to use \\s here instead of just checking for a space\n    // because different browsers use different whitespacing strategies ;_;\n    if (newStr.length > (i + 1) && /\\s/.test(newStr[i + 1])) {\n      return ['header', headerSize, newStr.slice(i + 1).trimLeft()];\n    }\n  } else if (formatChar.startsWith('*')) {\n    return ['list', 'ordered'];\n  }\n\n  // Look at this I mean can you believe I did this?\n  return ['sub', regexen.reduce((a, b) => a.replace(b[0], b[1]), str)];\n}\n\n\nconst processTextNode = (textNode, regexen = normalRegexen) => {\n  let parent = textNode.parentElement;\n  if (!parent) return;\n  const [type, result] = transformText(textNode.wholeText, regexen);\n\n  if (type === 'sub' && result !== textNode.wholeText) {\n    // markdown formatting occurred, sub in new stuff\n\n    // TODO: This creates garbage spans in the output. Is it possible to \n    // sub in HTML to the parent element at the caret?\n    const elt = document.createElement('span');\n    elt.classList.add('rf-fmt-span');\n    elt.innerHTML = result;\n    parent.insertBefore(elt, textNode);\n    parent.removeChild(textNode);\n  } else if (type === 'header') {\n    // Refuse to create a header at non-toplevel\n    if (!parent.classList.contains(\"rf-editor-line\") && !parent.classList.contains('rf-fmt-span')) return;\n\n    const hnode = document.createElement(`h${result}`);\n\n    // Insert a zero-width space and put the user's cursor after it\n    hnode.innerHTML = '&#8203;';\n\n    // if this is a toplevel rf-fmt-span\n    if (parent.classList.contains('rf-fmt-span')) {\n      const fmtSpan = parent;\n      if (fmtSpan.parentElement.classList.contains('rf-editor-line')) {\n        parent = fmtSpan.parentElement;\n        parent.removeChild(fmtSpan);\n      }\n    }\n\n    parent.insertBefore(hnode, textNode);\n    parent.removeChild(textNode);\n\n    moveCursor(hnode, 1);\n  } else if (type === 'list') {\n    state.insertingMarkdownList = true;\n    if (nodeIsOrHasAncestorOfNames(parent, 'UL')) {\n      return;\n    }\n    document.execCommand('insertUnorderedList');\n  }\n}\n\nconst processLastTextNode = (node) => {\n  if (!node) return; // This can happen if all text is deleted\n  if (node.nodeType === Node.TEXT_NODE) {\n    processTextNode(node, eolRegexen);\n  } else {\n    if (node.childNodes.length === 0) return;\n    processLastTextNode(node.childNodes[node.childNodes.length - 1]);\n  }\n}\n\nconst getActiveElement = () => {\n  const node = document.getSelection().anchorNode;\n  return (node.nodeType === 3 ? node.parentNode : node);\n}\n\n/**\n * Check if a node is or has an ancestor with a particular nodeName (DIV, LI, etc)\n * @param {*} node \n * @param {*} nodeNames Can be a string or an array of strings\n */\nconst nodeIsOrHasAncestorOfNames = (node, nodeNames) => {\n  if (typeof nodeNames === 'string') nodeNames = [nodeNames];\n\n  let next = node;\n  while (!next.classList.contains('rf-editor')) {\n    if (nodeNames.includes(next.nodeName)) return true;\n    next = next.parentNode;\n  }\n  return false;\n}\n\nexport default class Editor {\n  mount(editor) {\n    editor.classList.add('rf-editor');\n\n    editor.addEventListener('keydown', e => {\n      if (e.isComposing || e.keyCode === 229) return;\n      // Trap tabs\n      if (e.keyCode === 9) {\n        e.preventDefault();\n        const activeElt = getActiveElement();\n\n        // TODO: Refuse to do this within a header\n        if (nodeIsOrHasAncestorOfNames(activeElt, ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'])) return;\n\n        // normal insertUnorderedList will actually remove the list if there is one\n        // but indent will nest properly, like we want\n        const command = nodeIsOrHasAncestorOfNames(activeElt, 'LI') ? 'indent' : 'insertUnorderedList';\n\n        document.execCommand(command, false, null);\n      }\n    })\n\n    const observer = new MutationObserver((mutations, observer) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'characterData') {\n          processTextNode(mutation.target);\n        } else if (mutation.type === 'childList') {\n          // TBD: Handle formatting at the end of lists!\n          // Try to process the end of the last line, if the user has created a new one\n          if (mutation.target === editor && mutation.addedNodes.length === 1) {\n            const prevNode = mutation.addedNodes[0].previousSibling;\n            processLastTextNode(prevNode);\n          } else if (mutation.addedNodes.length === 1) {\n            const node = mutation.addedNodes[0];\n\n            // If true, we've just done an execCommand to create a list \n            if (state.insertingMarkdownList && node.nodeName === 'UL') {\n              state.insertingMarkdownList = false;\n              const li = node.childNodes[0];\n\n              console.log('removing this:', li.innerHTML);\n              li.innerHTML = '';\n            } else if (state.insertingMarkdownList && node.nodeName === 'LI') {\n              // It's possible for an LI to be inserted as a list, because\n              // execCommand insertXList at the end of a list splices the LI\n              // back onto the list\n              state.insertingMarkdownList = false;\n              console.log('removing this:', node.innerHTML);\n              node.innerHTML = '';\n            }\n\n            // Detect if a single div has been inserted, at non-toplevel\n            // If it has, splice it up to a toplevel .rf-editor-line\n            if (node.nodeName === 'DIV' && node.parentElement !== editor) {\n              node.parentElement.removeChild(node);\n              node.classList.add('rf-editor-line');\n              editor.appendChild(node);\n              // Move cursor to new node\n              const range = document.createRange();\n              range.setStart(node, 0);\n              range.collapse(true);\n              const sel = window.getSelection();\n              sel.removeAllRanges();\n              sel.addRange(range);\n            }\n          }\n        }\n      }\n    });\n\n    observer.observe(editor, {\n      attributes: true, childList: true, subtree: true, characterData: true\n    });\n  };\n}","import React, { useRef, useEffect } from 'react';\nimport Editor from './editor';\n\ntype RefractoryProps = {\n  children: React.ReactNode;\n}\n\nexport const Refractory = (props: RefractoryProps) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  const editorRef = useRef<Editor | null>(null);\n\n  useEffect(() => {\n    if (ref.current !== null) {\n      const editor = new Editor();\n      editorRef.current = editor;\n      editor.mount(ref.current);\n    }\n  }, [ref]);\n\n\n  return <div className=\"p2\" ref={ref} contentEditable={true} suppressContentEditableWarning={true}>\n    <div className=\"rf-editor-line\">Click to edit</div>\n\n  </div>\n}","import React from 'react';\nimport { Refractory } from './Refractory';\n\nconst App = () => {\n  return (\n    <div className=\"App flex justify-center pt4\">\n      <div className=\"flex\">\n\n        <div className=\"sidebar mr4\">\n          <div className=\"p2\">\n            <h3 className=\"h3 mb2\">Refractory</h3>\n\n            <p>Warning: contenteditable is gross. Approach with caution.</p>\n\n            <h3>### Type pound # then space to create a header</h3>\n\n            <p>Text with one set of <em>_underscores_</em> or <em>*asterisks*</em>&nbsp; is <em>italicized</em>.</p>\n\n            <p>Text with two sets of <strong>__underscores__</strong> or <strong>**asterisks**</strong>&nbsp; is <strong>bolded</strong>.</p>\n\n            <ul className=\"pl2\">\n              <li>Type an asterisk to begin a list</li>\n              <ul className=\"pl3\">\n                <li>Tab to indent, press enter on an empty item to dedent</li>\n              </ul>\n            </ul>\n\n            <p>\n              The source of this thing is at <a href=\"https://github.com/upvalue/refractory\">GitHub</a>.\n          </p>\n          </div>\n        </div>\n\n        <Refractory>\n          Editor goes here\n        </Refractory>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport './reset.css';\nimport './index.css';\nimport './basscss.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}